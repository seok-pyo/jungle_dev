#### 5월 18일 (일)

파이썬 가상환경
프로젝트마다 독립된 python 환경과 패키지를 갖도록 하는 폴더 기반의 격리 시스템.
각 프로젝트마다 독립된 파이썬과 pip 공간이 생긴다.
```
python3 -m venv .venv
source .venv/bin/activate
deactivate
```

1. 컴퓨터 시스템으로의 여행. Hello, World 프로그램의 일생 주기를 추적
- 1.1 정보는 비트와 컨텍스트로 이루어진다.
코드는 텍스트 문자 - 아스키 문자 - 연속된 바이트로 처리


2. 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.
  - 전처리 단계 - 컴파일 단계 - 어셈블리 단계 - 링크 단계
  - 전처리 단계 : 소스코드를 토큰 단위 텍스트 매크로 엔진에 넣어, 컴파일러가 이해할 수 있는 단일 번역 단위를 만드는 것.
  - 컴파일 단계 : 어셈블리어 프로그램으로 저장. 목적 파일을 생성.
  - 어셈블 단계 : 어셈블리어 파일을 이용해서 재배치 가능한 목적 파일을 생성한다.
  - 링킹 : 여러 목적 파일, 라이브러리를 하나의 주소 공간에 합치고 심볼을 해석

      - 링커가 실제로 하는 일 : 심볼테이블을 정리하고, 주소를 재배치 한다.
      1. 입력 수집 & 심볼 테이블 구축
      2. 섹션-병합 & 배치
      3. 재배치

  - 심볼은..
      - 컴파일러, 어셈블러, 링커가 "이 바이너리 조각을 이름으로 부르겠다"고 약속해 두는 메타데이터 레코드. 소스 코드의 식별자가 기계어 세계로 들어오면서 얻는 이름표 + 좌표 + 속성이라고 생각하면 된다.
      - 왜 필요한가?
          - 사람은 이름으로 코드를 짓고 부른다.
          - 기계는 절대/상대 주소(0x401070)만 이해한다.
          - 심볼을 그 사이를 잇는 사전(dictionary)
              - "prinft라는 이름이 필요하면, 이 주소(혹은 오프셋)으로 점프해"

3. 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.
 - 컴파일러가 어떻게 C 문장들을 기계어 코드로 번역하는지 알 필요가 있다.
```
- Switch문은 if-else 문을 연속해서 사용하는 것보다 언제나 더 효율적일까?
- 함수 호출 시 포인터 참조가 배열 인덱스보다 더 효율적인가?
- 합계를 지역변수에 저장하면 참조형태로 넘겨받은 인자를 사용하는 것보다 왜 루프가 더 빨리 실행되는가?
- 수식 연산시 괄호를 단순히 재배치 하기만 해도 함수가 더 빨리 실행되는 이유는 무엇인가?
- 컴파일러가 어떻게 C 문장들을 기계어 코드로 번역하는지 알 필요가 있다.
```

4. 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.
쉘은 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력 받아 그 명령을 실행한다.

5. 캐시가 중요하다.

6. 저장장치들은 계층구조를 이룬다

7. 운영체제는 하드웨어를 관리한다.
- 운영체제의 목적
- 운영체제는 2가지의 목적을 달성하기 위해 추상화를 통해 달성한다.
- 프로세스, 쓰레드, 가상메모리, 파일
8. 시스템은 다른 시스템과 네트워크를 사용하여 통신한다.

9. 중요한 주제들
- amdahl의 법칙


#### 5월 19일 (월)

공부 키워드
- 배열, 문자열
  - 2-2, 1-1, 1-1, 2, 1-4
  - 파이썬에서 배열을 리스트와 튜플로 구현할 수 있다. 리스트와 튜플은 컨테이너라고 하며 비슷한 기능을 하는듯하지만 원소를 변경할 수 있는지 없는지에 따라 차이가 있다.
  - 리스트는 뮤터블 리스트형 객체
  - call by ref / call by val / call by obj-ref
  - 튜플은 이뮤터블 자료형
  - 인덱스로 원소에 접근하기
  - 슬라이스식으로 원소에 접근하기
  - input.txt
  ```
    import sys
    sys.stdin = open("input.txt", "r")
  ```
- 반복문과 재귀함수
  -
- 복잡도(BigO, 시간, 공간)
  - 시간복잡도는 특정한 입력 크기에 대하여 코드가 얼마나 오래 걸리는지를 의미
  - 공간복잡도는 특정한 크기의 입력에 대하여 얼마나 많은 메모리를 차지하는지를 의미함.
  - BigO 표기법 :

- 정렬
   - 정렬 알고리즘
      - 정렬 안정성 / 외부, 내부 정렬
      - 정렬 안정성이란
        - 같은 크기의 배열을 정렬하더라도 같은 크기의 원소의 순서가 바뀌지 않는 것.
   - 버블 정렬
      - 한 방향으로 n - 1번 수행되는 패스, 이동한 원소간의 교환
      - 양방향으로 수행시 셰이커 정렬
   - 단순 선택 정렬
      - (정렬되지 않은 부분에서)가장 작은 원소를 알맞은 위치로 옮김
      - 떨어져 있는 원소를 교환하여 안정적이지 않음
   - 단순 삽입 정렬
      - 주목한 원소를 앞쪽의 알맞은 위치에 삽입하여 정렬
      - 삽입할 위치를 이진검색법으로 찾는 "이진 삽입 정렬"
   - 셸 정렬
      - 배열의 원소를 간격에 따라 그룹으로 나눠 정렬하여 병합하는 과정
   - 퀵 정렬
   - 병합 정렬
   - 힙 정렬
   - 도수 정렬
- 완전탐색
- 정수론

#### CS 기초
- 32 Bit / 64 Bit 차이
  - 컴퓨터 프로세서(CPU)가 데이터를 처리하는 방식
  - Bit는 CPU가 처리하는 데이터의 최소 단위인 레지스터의 크기가 몇 비트인지를 의미한다.
  - [64-bit windows 언제 그리고 왜 써야 할까](https://learn.microsoft.com/ko-kr/previous-versions/cc700734(v=technet.10)?redirectedfrom=MSDN)
- Python Call by value, Call by reference
  - 함수 호출 시 함수의 인자 전달 방식
  - 파이썬은 Call by object-reference 호출 방식을 사용
  - 파이썬에는 2가지의 자료형이 존재 immutable / mutable
- 실수 표현법(부동 소수점, 고정 소수점)
  - 컴퓨터에서 실수를 근삿값으로 표현할 때 사용.
  - 부동 소수점 방식은 실수를 가수와 지수 부분으로 나누어 표현하는것을 의미함
  - 가수 : 유효 숫자 범위 / 지수 : 소수점의 위치
  - 2의 보수, 1의 보수
  - 컴퓨터가 덧셈을 하는 방법

- C에서 Pointer 및 배열
- Garbage Collect
- Stack과 Heap, 메모리 구조
- jpg, png, gif 각각의 차이
- 2's complement, 1's complement
  - 컴퓨터가 연산을 하는 방법
- CPU vs GPU
- SSD, HDD

#### Algorithm 및 Data structure
- 시간 복잡도
   - 컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관계
- Recursion, Iteration
- Linked List, Array, Stack, Queue
- Deep Copy vs Shallow Copy
- 정렬, QuickSort, MergeSort, HeapSort
  - 정렬 안정도, 분할 정복 방식
  -
- Hash Table (collision, chaining, rehashing)
- DFS, BFS
- Graph, Tree
- Dynamic Programming, Greedy Algorithm
- 균형 이진 트리(Balanced BST) ex. AVL, RBTree

#### 0519
git / github
- 협업을 위해서
- svn(과거)
- 소스관리 도구(전자망치), 망치의 모든 것을 사용할 필요는 x
- github은 git을 이용한 원격 서비스

branch 전략
- 필요한 용도에 맞춰서 git을 사용하게 된다. ex) 파일 백업, 기능 분리, 버전 관리


#### 컴퓨터 시스템

- PC : PC는 CPU 내부에 존재하는 레지스터 중 하나이며 메모리를 가르키는 값을 가지고 있다. / 현재 실행 중인 명령어의 주소를 가지고 있는 레지스터.

- 프로세서(CPU) : 메인 메모리에 저장된 인스터럭션을 해독하는 엔진.

- 메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치.

- 레지스터 파일 : 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다.
레지스터 파일은 CPU 내부에 존재하는 작은 고속 저장소들의 묶음으로,
여러개의 레지스터를 한데 모은 논리적인 집합이다.

- 주요 레지스터 종료
  - 일반 목적 레지스터
  - 스택 포인터(SP)
  - 프로그램 카운터(PC)
  - 상태 레지스터(flags)

- ALU : ALU는 새 데이터와 주소 값을 계산한다.
- RISC 프로세서에서는 한 클럭 사이클에 동시에 레지스터 2개를 읽고 1개를 쓸 수 있도록 설계됨.


메모리 관점에서 전역변수와 정적변수의 차이점은?

전역 변수와 정적 변수의 차이는 링커가 심볼(symbol)을 어떻게 처리하는지에서 비롯됩니다.
전역 변수는 "외부 연결(external linkage)"을 가집니다. 즉, 심볼 테이블에 전역 심볼로 등록되어 다른 오브젝트 파일(모듈)에서도 참조할 수 있도록 링커가 관리합니다. 여러 파일에서 동일한 이름의 전역 변수가 있다면, 링커는 중복 정의 오류를 발생시킵니다.
정적 변수(파일 또는 함수 단위의 static 변수)는 "내부 연결(internal linkage)"을 가집니다. 링커는 이 변수를 해당 오브젝트 파일에서만 접근 가능한 로컬 심볼로 처리합니다. 즉, 동일한 이름의 static 변수가 여러 파일에 있어도 각각 별도의 심볼로 관리되어 충돌하지 않습니다.
정리하면, 링커는 심볼 테이블에서 전역 변수는 외부에서 접근 가능한 심볼로, 정적 변수는 해당 파일 내부에서만 접근 가능한 로컬 심볼로 구분하여 생성하고 관리합니다. 이로 인해 두 변수의 접근 범위와 연결 속성이 달라집니다.
즉, 메모리 할당 방식은 같지만, 링커가 심볼의 연결 속성을 다르게 만들어서 차이를 만듭니다.

#### 5월 20일 (화)

- 배열, 문자열
    - 배열 : "데이터를 순서대로 모아놓은 자료구조"
    - 배열 : 같은 타입의 데이터를 연속된 메모리에 순서대로 저장하는 선형 자료구조
    - 문자열 : 문자의 배열(시퀀스). 대부분 불변

- 반복문과 재귀함수
    - 반복문 : 특정 영역에서 반복적으로 함수를 호출할 수 있는 명령어
        - 장단점 : 오버헤드 적음
    - 재귀함수 : 자신을 스스로 다시 호출하는 함수
        - 장단점 : 코드가 직관적

- 복잡도
    - BigO 표기법 : 입력 크기 n이 무한히 커질 때 상한(최악/상대적) 성장률
    - 시간복잡도 : 연산을 수행할 때 걸리는 시간을 말한다.
    - 공간복잡도 : 연산을 수행할 때 필요한 메모리를 말한다.

- 정렬
    - 정렬은 원소를 기준을 가지고 나열하는 방식을 의미한다.
    - 정렬의 종류는
        - 버블 정렬(o(n^2))
        - 선택 정렬(o(n^2))
        - 삽입 정렬(o(n^2))
        - 셸 정렬(o(n^2))
        - 퀵 정렬(o(nlogn))
        - 병합 정렬(o(nlogn))
        - 힙 정렬(o(nlogn))
        - 도수 정렬(o(n + k))


- 완전탐색
    - 완전탐색은 전체 데이터를 모두 확인해서 원하는 결과를 찾아내는 방식을 의미한다.

- 정수론
    - 정수론이란..

#### 0521

- 파이썬 set 자료형
``` python
# set 생성
  my_set = set()
# 값 삭제
  my_set.remove(1) # 인자로 넘기는 값이 없으면 오류 발생
# discard 메서드를 사용하면 값이 세트에 없어도 오류 발생하지 않음
  my_set.discard(1)
# 값 존재 여부 확인
  'S' in my_set
# 모든값 제거
  my_set.clear()
```

- 파이썬 정렬
```python
mylist.sort() => 리스트형의 메서드, 리스트의 원본값을 직접 수정
sorted(mylist) => 내장 함수. 리스트의 원본값은 그대로. 정렬값은 반환
```
key와 lambda
- key와 lambda는 다른 개념이지만, lambda는 종종 key 값으로 사용된다.
- key에 내장 함수를 넣을 수 있음(abs, str.lower, len 등)
- lambda는 익명함수를 만들기 위한 간결한 문법
```
  lambda 매개변수 : 변수
```
- def로 만든 함수처럼 작동하지만, 간단히 함수를 만들 수 있음
- return문을 사용하지 않고 값을 반환함
```
add = lambda x, y : x + y
위와 동일함
add(x, y)
```
- key 함수로 사용
```
words = ["banana", "apple", "cherry"]
sorted(words, key=lambda x: len(x))
```
- map과 함께 사용
```
numbers = [1,2,3,4,5]
evens = list(map(lambda x: x ** 2, numbers))
```
- filter와 함께 사용
```
numbers = [1,2,3,4,5]
evens = list(filter(lambda x: x % 2 == 0, numbers))
```
- reduce와 함께 사용
```
from functools import reduce
product = reduce(lambda x,y : x*y, [1,2,3,4])
```


반복문과 재귀함수의 차이점
- 반복문은 스택 프레임을 계속 만들지 않음(한 함수 프레임 안에서 루프 실행)
- 재귀는 호출마다 새로운 스택 프레임이 생김 > 메모리 부담이 더 큼(재귀함수의 단점은 스택오버플로우의 위험성)

<Recursion>
To understand recursion, one must first understand recursion

primitive: 원시값

means of combinations: by which compound elements are built from simpler ones, and

means of abstraction, by which compound elements can be named and manipulated as units.

applicative order - python

normal order evaluation

recurcion 구현 - base condition - faith

Tail recursion : return문에서 연산이 없는 경우, 자기 자신만을 부르는 경우

설명 순서대로 함수를 작성하면 된다.
실행 순서를 따라갈 줄은 알아야 한다. > application order와 normal order evaluation

알고리즘, 컴퓨터 역사책(~ing)

컴퓨터에게 일을 시킨 목록, 풀려고 한 문제들의 집합
문제를 풀려고 노력했던 과거의 사람들의 존재

재귀의 조건
1. 작은 부분으로 쪼개지는 가
2. 기저조건: 부메랑
3. 하위 문제 호출
4. 결과 조합 : 조합이 없으면 꼬리재귀

#### 0522
1주에 부족했던 부분. 학습방법
2주차 발제
- 알고리즘, 자료구조(스택, 큐, linked List, 해시테이블)
- 진수변환, 1, 2의 보수
- 중간고사 > 자료구조, 알고리즘 2 과목

- 파이썬 기본 문법

- 컴퓨팅 사고로의 전환
  - 컴퓨터에게 어떻게 명령할 건지.
  - "컴퓨터는 어떻게 실행하는 가"를 이해하는 것.

- Week.2에는 기록을 어떻게 해야 할까?
- 팀 자료를 만들 수 있을까?
- 휘발되지 않는 자료로 만들 수 있을까?

