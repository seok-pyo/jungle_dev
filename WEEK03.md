#### WEEK03

- week 02 복기
  - 지난 주가 쉽지만은 않았다. 특히, 알고리즘 문제를 공부하는 과정에서 어려움이 있었는데, 여러 부분에서 벽들을 느꼈다. 2주간 잠을 줄이는 과정에서 체력적으로 어려움이 느껴졌던 것 같기도 하다. 체력적으로 관리를 잘해야 겠다는 생각을 했다. public domain static main 이곳에 처음 들어왔을 때에 마음가짐을 잊지 말자. 이 과정에서 더 단단해지고 성장할 수 있는 사람이 될 것이라고 생각한다.
    - 이곳에 왜 들어왔었지? 앞으로 어떻게 해야 하지? 힘든 과정들을 어떻게 이겨낼수 있는거지?
  - 학습 방법에 있어서는 풀이 과정을 보면서 익히려고 했는데, 어느정도? 도움이 되는 것 같기는 하다. 한 문제를 잘 기록해 놓고, 그 문제에서 중요한 것이 무엇이었는지 익히려고 하는 것이 중요한 것 같다.
    - 문제를 잘 기록하고, 한 문제씩 내 것으로 만드는 것.
    - 핵심적으로 내가 알아야 하는 것을 익혀야 한다.

- week 03
### 0529
  - 이번주에는 어떤 식으로 접근해서 학습을 해야할까?
    - 꾸준하게, 핵심적으로 중요한 것을 익힐 수 있도록.
    - 키워드 기억에 남겨야 하는 것.
    - 이것이 뭐가 중요하냐 라는 허무주의적 태도를 경계할 것.

### 0530
  - CSAPP 3장 프로그램의 기계수준 표현
    - 3.4 정보 접근하기
      - x86-64 주처리장치 cpu는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.

### 0531
  - 오퍼랜드란
    - 기계어 명령어가 실제로 연산할 대상이 되는 데이터나 그 위치를 가르키는 정보
      - Opcode(연산 코드) -> 무슨 연산을 할지
      - Operand(피연산자) -> 어디에, 무엇에 대해 연산할지 지정

  - DFS/BFS
    - 그래프를 탐색하기 위한 2가지 알고리즘.
    - 기본 자료구조 스택과 큐를 이해하고 있어야 한다.
    - 재귀함수를 알고 있어야 한다.
    - 그래프의 표현 방식에 대해서 알고 있어야 한다.
    - 노드 / 간선 / vertex
    - 그래프의 표현 방식에는 2가지가 존재. 인접행렬과 인접리스트
    - '인접하다'라는 뜻은 간선으로 연결되어 있다는 뜻
    - BFS는 가까운 거리부터 탐색하는 알고리즘 > 큐를 이용한다.
    - DFS는 멀리 있는 노드부터 확인하는 알고리즘 > 스택을 이용한다.

  ```python
  def dfs(graph, v, visited):
  visited[v] = True
  print(v, end=' ')
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)

graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

visited = [False] * 9

# dfs(graph, 1, visited)

from collections import deque

def bfs(graph, start, visited):

  queue = deque([start])
  visited[start] = True

  while queue:
    v = queue.popleft()
    print(v)
    for i in graph[v]:
      if not visited[i]:
        visited[i] = True
        queue.append(i)

bfs(graph, 1, visited)
```

### 0602

recursion - reduction : 코드 블럭 형태로 사용할 수 있도록

### 문제해결기법
분할정복 / 백트랙킹 / 그리디 / 다이나믹 프로그래밍

분할정복 :
divide - delegate - combine
* 주어진 인스턴스가 작으면 recursion 없이 해결
> 기저 조건 (예를 들어, 머지소트에서 하나의 원소는 정렬이 된 상태로, 해결된 것으로 이해)

Binary Search
- Binary search는 사실 D&C
* 탐색에서 가장 중요한 전략은 탐색 범위를 줄이는 것

Multiplication 재귀
- 카라추바

다이나믹 프로그래밍
- recursion을 이용, 재귀에 바탕을 두고 있음
- 지수함수 만큼 시간복잡도가 증가
- 재귀를 사용할 때 중복되는 값을 메모해 놓고 사용하자.

- 재귀 문제로 해결해야 하는 방식을 알고 있고,
- 부분 문제의 답을 자료구조에 저장하고, 다시 이용하는 방식으로 사용한다.
* `점화식` <=> `재귀`
* `recurrence` <=> `recursion`
* 수식의 명료함 <=> 알고리즘

* 큰 값에서 깎아내는 것 > `재귀`
* 피보나치를 손으로 적어서 올라가는 것 > `DP`

- LCS(Longest common subsequence)
  - String matching
  - 문제의 접근 방식을 다시 정의
    - CS는 같은 원소끼리 짝을 맺어준다.
    - 원소끼리 짝을 맞춰지면 이후에 배열을 보지 않는다. 배열의 슬라이싱 => `매칭된 선이 교차하면 안되므로!`
    - base 케이스 부터 생각!

<br>
<br>

## 해시테이블

### 해시테이블의 탐색속도는?
평균의 경우:

최악의 경우:

### 해시테이블에 접근할 때 마다 해싱을 수행할까?

### 해시연산의 시간복잡도는?

### 해시함수의 연산속도가 빠른 이유는?

### 파이썬에서 해시 충돌 시 해결 방법은?

### 파이썬에서 해시테이블은 어떤 자료구조로 만들어져 있을까?

## 트라이

시간복잡도 / 공간복잡도

### 0603

#### 콜 스택
- 콜 스택은 스택 프레임의 모음이다.

- 함수 호출 정보를 담고 있는 자료구조

- The call stack is a data structure used by the program during runtime to manage function calls and local variables.

- 함수의 런타임 동안 사용되는, 함수의 호출과 관련된 정보와 지역 변수를 관리한다.

- 함수의 인자 / 지역변수 / 반환 주소값 들을 스택 프레임이 가지고 있다.

- 런타임 스택 / 콜 스택 / 스택 프레임

### WEEK03 공부키워드

- 그래프의 종류 / 그래프의 표현방식

- BFS/DFS

- 위상 정렬

- B-tree

- 트라이

- 다익스트라 / 플로이드 와샬

- 최소 신장 트리(Minimum Spanning Tree)
  - 최소 신장 트리란
    - 무방향 그래프에서 모든 정점을 포함하고, 사이클 없이 연결된 트리 형태의 부분 그래프
    - 이 중 간선들의 가중치 합이 최소인 신장 트리를 최소 신장 트리라고 한다.

  - 최소 신장 트리의 특징
    - 정점 개수가 v개 일때, MST는 항상 v - 1개의 간선을 가진다.
    - 사이클이 없음
    - 여러 개의 MST가 존재할 수 있음

  - 해당 알고리즘이 사용되는 예시
    - 최대한 비용을 절감하면서 모든 지점을 다 연결해야 하는 경우

  - 대표 알고리즘
    - 크루스칼(유니온-파인드 사용) : 간선을 가중치 순으로 정렬하여, 가장 낮은 가중치부터 선택

  - 간선을 가중치 기준으로 오름차순 정렬한 뒤, 사이클을 만들지 않는 선에서 간선을 하나씩 선택해 나가는 방식. 선택한 간선들이 모든 정점을 연결하고, 최소 가중치가 되도록 함.

  1. 모든 간선을 가중치를 기준으로 오름차순 정렬을 수행
  2. 가중치가 가장 낮은 노드부터 하나씩 선택
  3. 선택한 간선이 사이클을 만든다면 제외
  4. 사이클 판단을 위해 유니온 파인드 자료구조 사용
  5. 간선이 v-1개가 되면 알고리즘 종료

### 유니온 파인드
- 서로 다른 노드가 같은 집합(트리)에 속하는지 빠르게 판별하고, 합치기 위한 자료구조


