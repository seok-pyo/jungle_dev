#### WEEK03

- week 02 복기
  - 지난 주가 쉽지만은 않았다. 특히, 알고리즘 문제를 공부하는 과정에서 어려움이 있었는데, 여러 부분에서 벽들을 느꼈다. 2주간 잠을 줄이는 과정에서 체력적으로 어려움이 느껴졌던 것 같기도 하다. 체력적으로 관리를 잘해야 겠다는 생각을 했다. public domain static main 이곳에 처음 들어왔을 때에 마음가짐을 잊지 말자. 이 과정에서 더 단단해지고 성장할 수 있는 사람이 될 것이라고 생각한다.
    - 이곳에 왜 들어왔었지? 앞으로 어떻게 해야 하지? 힘든 과정들을 어떻게 이겨낼수 있는거지?
  - 학습 방법에 있어서는 풀이 과정을 보면서 익히려고 했는데, 어느정도? 도움이 되는 것 같기는 하다. 한 문제를 잘 기록해 놓고, 그 문제에서 중요한 것이 무엇이었는지 익히려고 하는 것이 중요한 것 같다.
    - 문제를 잘 기록하고, 한 문제씩 내 것으로 만드는 것.
    - 핵심적으로 내가 알아야 하는 것을 익혀야 한다.

- week 03
### 0529
  - 이번주에는 어떤 식으로 접근해서 학습을 해야할까?
    - 꾸준하게, 핵심적으로 중요한 것을 익힐 수 있도록.
    - 키워드 기억에 남겨야 하는 것.
    - 이것이 뭐가 중요하냐 라는 허무주의적 태도를 경계할 것.

### 0530
  - CSAPP 3장 프로그램의 기계수준 표현
    - 3.4 정보 접근하기
      - x86-64 주처리장치 cpu는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.

### 0531
  - 오퍼랜드란
    - 기계어 명령어가 실제로 연산할 대상이 되는 데이터나 그 위치를 가르키는 정보
      - Opcode(연산 코드) -> 무슨 연산을 할지
      - Operand(피연산자) -> 어디에, 무엇에 대해 연산할지 지정

  - DFS/BFS
    - 그래프를 탐색하기 위한 2가지 알고리즘.
    - 기본 자료구조 스택과 큐를 이해하고 있어야 한다.
    - 재귀함수를 알고 있어야 한다.
    - 그래프의 표현 방식에 대해서 알고 있어야 한다.
    - 노드 / 간선 / vertex
    - 그래프의 표현 방식에는 2가지가 존재. 인접행렬과 인접리스트
    - '인접하다'라는 뜻은 간선으로 연결되어 있다는 뜻
    - BFS는 가까운 거리부터 탐색하는 알고리즘 > 큐를 이용한다.
    - DFS는 멀리 있는 노드부터 확인하는 알고리즘 > 스택을 이용한다.

  ```python
  def dfs(graph, v, visited):
  visited[v] = True
  print(v, end=' ')
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)

graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

visited = [False] * 9

# dfs(graph, 1, visited)

from collections import deque

def bfs(graph, start, visited):

  queue = deque([start])
  visited[start] = True

  while queue:
    v = queue.popleft()
    print(v)
    for i in graph[v]:
      if not visited[i]:
        visited[i] = True
        queue.append(i)

bfs(graph, 1, visited)
  ```

