#### WEEK03

- week 02 복기
  - 지난 주가 쉽지만은 않았다. 특히, 알고리즘 문제를 공부하는 과정에서 어려움이 있었는데, 여러 부분에서 벽들을 느꼈다. 2주간 잠을 줄이는 과정에서 체력적으로 어려움이 느껴졌던 것 같기도 하다. 체력적으로 관리를 잘해야 겠다는 생각을 했다. public domain static main 이곳에 처음 들어왔을 때에 마음가짐을 잊지 말자. 이 과정에서 더 단단해지고 성장할 수 있는 사람이 될 것이라고 생각한다.
    - 이곳에 왜 들어왔었지? 앞으로 어떻게 해야 하지? 힘든 과정들을 어떻게 이겨낼수 있는거지?
  - 학습 방법에 있어서는 풀이 과정을 보면서 익히려고 했는데, 어느정도? 도움이 되는 것 같기는 하다. 한 문제를 잘 기록해 놓고, 그 문제에서 중요한 것이 무엇이었는지 익히려고 하는 것이 중요한 것 같다.
    - 문제를 잘 기록하고, 한 문제씩 내 것으로 만드는 것.
    - 핵심적으로 내가 알아야 하는 것을 익혀야 한다.

- week 03
### 0529
  - 이번주에는 어떤 식으로 접근해서 학습을 해야할까?
    - 꾸준하게, 핵심적으로 중요한 것을 익힐 수 있도록.
    - 키워드 기억에 남겨야 하는 것.
    - 이것이 뭐가 중요하냐 라는 허무주의적 태도를 경계할 것.

### 0530
  - CSAPP 3장 프로그램의 기계수준 표현
    - 3.4 정보 접근하기
      - x86-64 주처리장치 cpu는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.

### 0531
  - 오퍼랜드란
    - 기계어 명령어가 실제로 연산할 대상이 되는 데이터나 그 위치를 가르키는 정보
      - Opcode(연산 코드) -> 무슨 연산을 할지
      - Operand(피연산자) -> 어디에, 무엇에 대해 연산할지 지정

  - DFS/BFS
    - 그래프를 탐색하기 위한 2가지 알고리즘.
    - 기본 자료구조 스택과 큐를 이해하고 있어야 한다.
    - 재귀함수를 알고 있어야 한다.
    - 그래프의 표현 방식에 대해서 알고 있어야 한다.
    - 노드 / 간선 / vertex
    - 그래프의 표현 방식에는 2가지가 존재. 인접행렬과 인접리스트
    - '인접하다'라는 뜻은 간선으로 연결되어 있다는 뜻
    - BFS는 가까운 거리부터 탐색하는 알고리즘 > 큐를 이용한다.
    - DFS는 멀리 있는 노드부터 확인하는 알고리즘 > 스택을 이용한다.

  ```python
  def dfs(graph, v, visited):
  visited[v] = True
  print(v, end=' ')
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)

graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

visited = [False] * 9

# dfs(graph, 1, visited)

from collections import deque

def bfs(graph, start, visited):

  queue = deque([start])
  visited[start] = True

  while queue:
    v = queue.popleft()
    print(v)
    for i in graph[v]:
      if not visited[i]:
        visited[i] = True
        queue.append(i)

bfs(graph, 1, visited)
```

### 0602

recursion - reduction : 코드 블럭 형태로 사용할 수 있도록

### 문제해결기법
분할정복 / 백트랙킹 / 그리디 / 다이나믹 프로그래밍

분할정복 :
divide - delegate - combine
* 주어진 인스턴스가 작으면 recursion 없이 해결
> 기저 조건 (예를 들어, 머지소트에서 하나의 원소는 정렬이 된 상태로, 해결된 것으로 이해)

Binary Search
- Binary search는 사실 D&C
* 탐색에서 가장 중요한 전략은 탐색 범위를 줄이는 것

Multiplication 재귀
- 카라추바

다이나믹 프로그래밍
- recursion을 이용, 재귀에 바탕을 두고 있음
- 지수함수 만큼 시간복잡도가 증가
- 재귀를 사용할 때 중복되는 값을 메모해 놓고 사용하자.

- 재귀 문제로 해결해야 하는 방식을 알고 있고,
- 부분 문제의 답을 자료구조에 저장하고, 다시 이용하는 방식으로 사용한다.
* `점화식` <=> `재귀`
* `recurrence` <=> `recursion`
* 수식의 명료함 <=> 알고리즘

* 큰 값에서 깎아내는 것 > `재귀`
* 피보나치를 손으로 적어서 올라가는 것 > `DP`

- LCS(Longest common subsequence)
  - String matching
  - 문제의 접근 방식을 다시 정의
    - CS는 같은 원소끼리 짝을 맺어준다.
    - 원소끼리 짝을 맞춰지면 이후에 배열을 보지 않는다. 배열의 슬라이싱 => `매칭된 선이 교차하면 안되므로!`
    - base 케이스 부터 생각!